namespace AppInfoGen;

using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

internal sealed record BuildInfo
{
    public string AppVersion { get; set; } = string.Empty;
    public string InformationalVersion { get; set; } = string.Empty;
    public string Product { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string GitHash { get; set; } = string.Empty;
    public DateTime BuildTime { get; set; } = DateTime.UtcNow;
}

[Generator(LanguageNames.CSharp)]
public class AppInfoGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var buildInfoValuesProvider = context.CompilationProvider.Select(static (compilation, _) =>
        {
            var attributes = compilation.Assembly.GetAttributes();
            string informationalVersion = GetAttributeValueOrEmpty(attributes, "AssemblyInformationalVersionAttribute");

            BuildInfo bi = new()
            {
                InformationalVersion = informationalVersion,
                Product = GetAttributeValueOrEmpty(attributes, "AssemblyProductAttribute"),
                Description = GetAttributeValueOrEmpty(attributes, "AssemblyDescriptionAttribute"),
                GitHash = GetGitHash(informationalVersion),
                AppVersion = GetAppVersion(informationalVersion)
            };
            return bi;
        });

        context.RegisterSourceOutput(buildInfoValuesProvider, static (ctx, buildInfo) =>
        {
            ctx.AddSource("BuildInfo.g.cs", GenerateSource(buildInfo));
        });
    }

    private static string GetAttributeValueOrEmpty(ImmutableArray<AttributeData> attributes, string attributeName)
        => attributes.Where(a => a.AttributeClass?.Name == attributeName).Select(a => (string)a.ConstructorArguments[0].Value!).SingleOrDefault() ?? "";

    private static string GetGitHash(string productVersion)
    {
        if (string.IsNullOrEmpty(productVersion))
            return string.Empty;
        const string GitHashMetadataPrefix = "+git";
        int startIndex = productVersion.IndexOf(GitHashMetadataPrefix);
        if (startIndex < 0)
            return string.Empty;

        startIndex += GitHashMetadataPrefix.Length;
        int endIndex = productVersion.IndexOf('+', startIndex);
        if (endIndex == startIndex)
            return string.Empty;
        if (endIndex > startIndex)
            return productVersion.Substring(startIndex, endIndex - startIndex);
        return productVersion.Substring(startIndex);
    }

    private static string GetAppVersion(string productVersion)
    {
        if (string.IsNullOrEmpty(productVersion))
            return string.Empty;
        int metaPostfixIndex = productVersion.IndexOf('+');
        return (metaPostfixIndex < 0) ? productVersion : productVersion.Substring(0, metaPostfixIndex);
    }

    private static string GenerateSource(BuildInfo buildInfo)
    {
        return 
        $$"""
        /// <autogenerated/>
        
        using System;
        using System.Globalization;

        public static class AppInfo
        {
            public const string AppName = "{{buildInfo.Product}}";
            public const string AppVersion = "{{buildInfo.AppVersion}}";
            public const string ProductVersion = "{{buildInfo.InformationalVersion}}";
            public static readonly DateTime BuildTime = DateTime.ParseExact("{{buildInfo.BuildTime:O}}", "O", CultureInfo.InvariantCulture, DateTimeStyles.None);
            public const string GitHash = "{{buildInfo.GitHash}}";
            public const string ProductDescription = "{{buildInfo.Description}}";
            public const string InfoLine = "{{buildInfo.Product}} ver.{{buildInfo.AppVersion}} from {{buildInfo.BuildTime:yyyy-MM-dd HH:mm:ss}} (UTC)";
        }
        """;
    }
}

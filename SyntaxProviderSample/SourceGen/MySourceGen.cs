namespace SourceGen;

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class MySourceGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is ClassDeclarationSyntax,
            transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
        );

        context.RegisterSourceOutput(classes, Execute);
    }

    private static void Execute(SourceProductionContext context, ClassDeclarationSyntax classSyntax)
    {
        string namespaceName = "Undefined";
        if (classSyntax.Parent is BaseNamespaceDeclarationSyntax namespaceSyntax)
        {
            namespaceName = namespaceSyntax.Name.ToString();
        }

        string className = classSyntax.Identifier.Text;
        string fileName = $"{namespaceName}.{className}.g.cs";
        string[] properties = classSyntax.ChildNodes().OfType<PropertyDeclarationSyntax>().Select(p => p.Identifier.Text).ToArray();

       string source = 
        $$"""
        /// <autogenerated/>
        namespace {{namespaceName}};

        partial class {{className}}
        {
            public override string ToString()
            {
                return $"{{string.Join(",", properties.Select(p => string.Concat(p, ": {", p, "}")))}}";
            }
        }
        """;
        context.AddSource(fileName, source); 
    }
}

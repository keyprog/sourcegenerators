namespace SourceGen;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator(LanguageNames.CSharp)]
public class MySourceGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is ClassDeclarationSyntax cd
                                && cd.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
                                && cd.ChildNodes().Any(c => c.IsKind(SyntaxKind.PropertyDeclaration)),
            transform: (c, _) => (INamedTypeSymbol)c.SemanticModel.GetDeclaredSymbol(c.Node)!
        );

        context.RegisterSourceOutput(classes, Execute);
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol type)
    {

        string className = type.Name;
        string fileName = $"{type.ContainingNamespace}.{className}.g.cs";
        var properties = type.GetMembers().Where(m => m.Kind == SymbolKind.Property);

        string source =
         $$"""
        /// <autogenerated/>
        namespace {{type.ContainingNamespace}};

        partial class {{className}}
        {
            public override string ToString()
            {
                return $"{{string.Join(",", properties.Select(p => string.Concat(p.Name, ": {", p.Name, "}")))}}";
            }
        }
        """;
        context.AddSource(fileName, source);
    }
}
